<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>About - MemoryFile</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --page-bg: #fff;
      --page-fg: #000;
      --muted-fg: #666;
      --border: #eee;
      --link: #0066ff;
      --link-hover: #000;
    }
    html, body { height: 100%; }
    body {
      font-family: -apple-system, system-ui, sans-serif;
      line-height: 1.6;
      background: var(--page-bg);
      color: var(--page-fg);
      display: flex;
      flex-direction: column;
    }
    .container {
      flex: 1;
      max-width: 600px;
      margin: 0 auto;
      padding: 60px 24px 24px;
      width: 100%;
      display: flex;
      flex-direction: column;
    }
    h1 {
      font-size: 32px;
      font-weight: 600;
      letter-spacing: -0.5px;
      margin-bottom: 8px;
    }
    h2 { font-size: 20px; font-weight: 600; margin: 36px 0 16px; }
    h3 { font-size: 16px; font-weight: 600; margin: 24px 0 12px; }
    p { margin-bottom: 16px; color: var(--muted-fg); }
    ul, ol { margin: 16px 0 16px 24px; color: var(--muted-fg); }
    li { margin-bottom: 8px; }
    code {
      background: rgba(0, 0, 0, 0.05);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'SF Mono', Monaco, monospace;
      font-size: 13px;
    }
    pre {
      background: rgba(0, 0, 0, 0.05);
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 16px 0;
      font-size: 13px;
      line-height: 1.5;
      color: var(--page-fg);
    }
    a { color: var(--link); text-decoration: none; }
    a:hover { color: var(--link-hover); text-decoration: underline; }
    .subtitle { color: var(--muted-fg); margin-bottom: 32px; }
    .nav { margin-bottom: 24px; font-size: 14px; color: var(--muted-fg); }
    .nav a { color: var(--muted-fg); }
    .nav a:hover { color: var(--page-fg); }
    table { border-collapse: collapse; width: 100%; margin: 16px 0; }
    th, td {
      text-align: left;
      padding: 8px;
      border-bottom: 1px solid var(--border);
      font-size: 14px;
      color: var(--muted-fg);
    }
    th { font-weight: 600; color: var(--page-fg); }
    hr { border: none; border-top: 1px solid var(--border); margin: 32px 0; }
    footer {
      margin-top: auto;
      padding: 24px 0;
      border-top: 1px solid var(--border);
      color: #999;
      font-size: 14px;
      flex-shrink: 0;
    }
    footer a { color: #999; text-decoration: none; }
    footer a:hover { color: var(--page-fg); text-decoration: underline; }
    @media (prefers-color-scheme: dark) {
      :root {
        --page-bg: #000;
        --page-fg: #fff;
        --muted-fg: #666;
        --border: #222;
        --link: #79b8ff;
        --link-hover: #fff;
      }
      code { background: rgba(255, 255, 255, 0.1); }
      pre { background: rgba(255, 255, 255, 0.08); }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="nav"><a href="../">Home</a></div>

    <h1>About MemoryFile</h1>
    <p class="subtitle">Technical overview, security model, and current capabilities</p>

    <h2>Architecture</h2>
    <p>A MemoryFile is a single HTML file that bundles:</p>
    <ol>
      <li><strong>HTML UI</strong> for the interface</li>
      <li><strong>CSS styles</strong> for presentation</li>
      <li><strong>JavaScript app code</strong> for logic</li>
      <li><strong>SQLite WASM runtime</strong> for the database engine</li>
      <li><strong>Embedded database</strong> as base64, optionally encrypted</li>
      <li><strong>Trust + commit metadata</strong> for verification and history</li>
    </ol>
    <p>
      On load, the browser decodes the embedded database, decrypts it if needed,
      and initializes SQLite in memory. On save, the database is exported,
      encrypted if enabled, and the HTML file is rebuilt with updated data.
      Saved files inline the SQLite WASM loader when available so the export
      is fully standalone.
    </p>

    <h2>File lifecycle</h2>
    <pre>1. User opens myapp.html
2. Browser loads and parses HTML
3. JavaScript decodes (and decrypts) database
4. SQLite WASM initializes in memory
5. User interacts, modifies data
6. App exports database to binary
7. JavaScript encrypts (optional) and base64-encodes
8. JavaScript rebuilds HTML with new data
9. File System API saves in place or downloads a copy</pre>

    <h2>Trust and verification</h2>
    <p>Content-addressed filenames include a hash of the file contents.</p>
    <p>Example: <code>contract.a1b2c3.html</code></p>
    <p>
      The hash is derived from SHA-256 of the entire file. Change one byte and
      the hash changes. This makes tampering visible.
    </p>
    <h3>How files verify themselves</h3>
    <ol>
      <li>Read the filename and extract the hash</li>
      <li>Hash the current file contents</li>
      <li>Compare expected vs actual hash</li>
      <li>Show VERIFIED or TAMPERED badge</li>
    </ol>
    <p>
      This is self-verification, not external verification. An attacker who
      modifies both code and content can bypass checks, so social context and
      expected filenames still matter.
    </p>

    <h2>Security model</h2>
    <h3>Protected by default</h3>
    <ul>
      <li>Encryption at rest via AES-256-GCM (enabled by default)</li>
      <li>Content tampering detection via content-addressed filenames</li>
      <li>SQL injection protection when using parameterized queries</li>
    </ul>
    <h3>Not protected</h3>
    <ul>
      <li>Malicious HTML or JavaScript inside the file</li>
      <li>Data in memory while the app is running</li>
      <li>Supply chain risks if bundled runtime files are replaced</li>
    </ul>
    <p>
      See <a href="../SECURITY.md">SECURITY.md</a> for full details on encryption,
      CSP requirements, and threat model guidance.
    </p>

    <h2>Browser compatibility</h2>
    <table>
      <tr>
        <th>Environment</th>
        <th>JS execution</th>
        <th>Save in place</th>
        <th>Export</th>
        <th>Notes</th>
      </tr>
      <tr>
        <td>Desktop Chrome/Edge (http/https)</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>Yes</td>
        <td>File System Access API</td>
      </tr>
      <tr>
        <td>Desktop Firefox/Safari (http/https)</td>
        <td>Yes</td>
        <td>No</td>
        <td>Yes</td>
        <td>Downloads a new copy</td>
      </tr>
      <tr>
        <td>iOS Safari/Chrome opened from Files</td>
        <td>No</td>
        <td>No</td>
        <td>No</td>
        <td>Quick Look blocks JS</td>
      </tr>
      <tr>
        <td>Android Chrome opened from Downloads</td>
        <td>Yes</td>
        <td>No</td>
        <td>Limited</td>
        <td>External files may not load</td>
      </tr>
      <tr>
        <td>Mobile browsers (http/https)</td>
        <td>Yes</td>
        <td>No</td>
        <td>Yes</td>
        <td>Use export/share</td>
      </tr>
    </table>

    <h2>Performance and limits</h2>
    <ul>
      <li>Base64 adds about 33% size overhead</li>
      <li>Entire database loads into memory</li>
      <li>Large files can hit browser memory limits</li>
      <li>Typical smooth range is 50-100 MB databases</li>
    </ul>
    <p>
      See <a href="../docs/LIMITS.md">docs/LIMITS.md</a> and run
      <code>tests/limits-runner.html</code> on your hardware for concrete limits.
    </p>

    <h2>Use cases</h2>
    <h3>For developers</h3>
    <ul>
      <li>Offline-first tools with no server dependency</li>
      <li>Portable data collection or inspection apps</li>
      <li>Shareable datasets with built-in queries</li>
      <li>Prototypes for database-backed apps</li>
      <li>Documentation bundled with structured data</li>
    </ul>
    <h3>For end users</h3>
    <ul>
      <li>Verified documents shared over email or USB</li>
      <li>Offline access in low-connectivity environments</li>
      <li>Personal databases with strong portability</li>
      <li>Self-contained records with tamper detection</li>
    </ul>

    <h2>Comparison to alternatives</h2>
    <p><strong>LocalStorage</strong> is browser-specific. MemoryFile is portable.</p>
    <p><strong>IndexedDB</strong> is performant but domain-locked. MemoryFile is SQL and shareable.</p>
    <p><strong>Server + database</strong> requires hosting. MemoryFile runs offline.</p>
    <p><strong>TiddlyWiki</strong> stores JSON. MemoryFile stores SQL.</p>
    <p><strong>SQLite files</strong> need a separate app. MemoryFile bundles UI + data.</p>

    <h2>Embedded vs OPFS</h2>
    <p>
      MemoryFile focuses on embedded, portable HTML exports. SQLite WASM supports
      OPFS for higher performance, and the core library exposes detection, but the
      shipped examples are embedded-first. A common pattern is OPFS for daily work
      and embedded exports for sharing or backup.
    </p>

    <h2>Testing</h2>
    <p>
      Open <code>test/index.html</code> for the full browser test runner. Targeted
      runners live under <code>tests/</code>, including limits, trust, encryption,
      and inline WASM coverage.
    </p>

    <h2>Future possibilities</h2>
    <ul>
      <li>Compression before base64 encoding</li>
      <li>Incremental saves for large files</li>
      <li>OPFS hybrid reference implementation</li>
      <li>Multi-file splitting for big datasets</li>
      <li>P2P sync between instances</li>
      <li>Service Worker caching</li>
      <li>Digital signatures for creator verification</li>
    </ul>

    <footer>
      <a href="../">Home</a> 路
      <a href="/about/">About</a> 路
      <a href="/01-basic-demo.html">Examples</a> 路
      <a href="https://github.com/AmbientAccent/memoryfile">GitHub</a> 路
      <a href="https://github.com/AmbientAccent/memoryfile/tree/main/docs">Docs</a>
    </footer>
  </div>
</body>
</html>
